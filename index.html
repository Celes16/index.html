<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Multithreading com Seguran√ßa: Descubra o Poder do Rust</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 900px;
      margin: auto;
      padding: 20px;
      background-color: #f5f7fa;
      color: #333;
      line-height: 1.6;
    }
    h1, h2 {
      color: #e91e63; /* rosa */
    }
    h1 {
      font-size: 2.8rem;
      text-align: center;
      margin-bottom: 0.5rem;
    }
    h2 {
      margin-top: 2rem;
      margin-bottom: 0.8rem;
      font-weight: 700;
    }
    p {
      font-size: 1.1rem;
      margin-top: 0.5rem;
    }
    ul {
      list-style: disc inside;
      margin-left: 0;
      margin-bottom: 1.5rem;
      color: #555;
    }
    pre {
      background-color: #2d2d2d;
      color: #f8f8f2;
      padding: 15px;
      border-radius: 6px;
      overflow-x: auto;
      font-family: Consolas, Monaco, monospace;
      font-size: 0.9rem;
      margin-top: 0.75rem;
      margin-bottom: 1.5rem;
    }
    .badge-outline {
      border: 1px solid #e91e63; /* rosa */
      color: #e91e63;
      padding: 5px 12px;
      font-weight: 600;
      border-radius: 20px;
      display: inline-block;
      margin-bottom: 0.75rem;
      font-size: 0.9rem;
    }

    /* Estilo para a tabela */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
      margin-bottom: 2rem;
    }
    table caption {
      caption-side: top;
      font-weight: 700;
      color: #e91e63; /* rosa */
      font-size: 1.3rem;
      margin-bottom: 0.5rem;
      text-align: left;
    }
    table th, table td {
      border: 1px solid #d1d5db;
      padding: 10px 12px;
      text-align: left;
      color: #374151;
    }
    table th {
      background-color: #f48fb1; /* rosa claro */
      color: white;
    }
    table tbody tr:nth-child(even) {
      background-color: #f9fafb;
    }

    /* Responsividade */
    @media (max-width: 600px) {
      body {
        padding: 12px;
      }
      h1 {
        font-size: 2rem;
      }
      h2 {
        font-size: 1.3rem;
      }
      p, ul {
        font-size: 1rem;
      }
      table th, table td {
        padding: 8px;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <main>
    <section style="text-align:center;">
      <h1>Multithreading com Seguran√ßa: Descubra o Poder do Rust</h1>
    </section>
    
    <section>
      
      <h2>Introdu√ß√£o ao Rust</h2>
      <p>
        Rust √© uma linguagem de programa√ß√£o moderna, lan√ßada oficialmente em 2015 pela Mozilla,
        com o objetivo de unir <strong>desempenho de baixo n√≠vel</strong> e <strong>seguran√ßa de alto n√≠vel</strong>.
        Seu sistema inovador de <em>ownership</em> e <em>borrowing</em> previne falhas comuns,
        como ponteiros nulos e <em>data races</em>, j√° na fase de compila√ß√£o,
        garantindo c√≥digo robusto sem sacrificar velocidade.
      </p>
      <p>
        Al√©m de aplica√ß√µes em <strong>sistemas cr√≠ticos</strong> e <strong>programa√ß√£o multithread</strong>,
        Rust tamb√©m vem ganhando espa√ßo em <strong>sistemas embarcados</strong>,
        <strong>ferramentas de linha de comando (CLI)</strong>, <strong>WebAssembly</strong>,
        <strong>desenvolvimento de jogos</strong> e <strong>machine learning</strong>.
        Essa versatilidade, aliada a uma comunidade ativa e em crescimento,
        faz do Rust uma das linguagens mais admiradas e promissoras da atualidade.
      </p>
    </section>

    <section>
      <h2> E Por que Multithreading?</h2>
      <p>
        Imagine uma cozinha com v√°rios cozinheiros trabalhando ao mesmo tempo.
        Isso √© o que a programa√ß√£o multithread faz: divide e conquista.
        Por√©m, isso gera desafios de seguran√ßa e bugs complexos.
        O Rust resolve isso com uma abordagem √∫nica baseada em seguran√ßa por design.
      </p>
    </section>

    <section>
      <h2>üîç Recursos Poderosos do Rust</h2>
      <ul>
        <li><strong>Ownership e Borrowing</strong>: evita data races em tempo de compila√ß√£o.</li>
        <li><strong>Traits Send e Sync</strong>: seguran√ßa garantida entre threads.</li>
        <li><strong>Canal (channel)</strong>: comunica√ß√£o segura entre threads.</li>
        <li><strong>Mutex, Arc e ThreadPool</strong>: controle de concorr√™ncia f√°cil e seguro.</li>
        <li><strong>Sem Garbage collector "Coletor de Lixo"</strong>: alta performance com baixo overhead.</li>
      </ul>
    </section>

    <section>
      <table>
        <caption>Mecanismos de Compartilhamento Seguro</caption>
        <thead>
          <tr>
            <th>Mecanismo</th>
            <th>Uso Ideal</th>
            <th>Vantagens</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Arc&lt;T&gt;</td>
            <td>Dados imut√°veis compartilhados</td>
            <td>Contagem at√¥mica de refer√™ncias</td>
          </tr>
          <tr>
            <td>Arc&lt;Mutex&lt;T&gt;&gt;</td>
            <td>Dados mut√°veis compartilhados</td>
            <td>Acesso exclusivo garantido</td>
          </tr>
          <tr>
            <td>Arc&lt;RwLock&lt;T&gt;&gt;</td>
            <td>Muitos leitores, poucos escritores</td>
            <td>Mais eficiente que Mutex para leitura</td>
          </tr>
          <tr>
            <td>mpsc::channel</td>
            <td>Comunica√ß√£o entre threads</td>
            <td>Evita locks com message passing</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section>
      <h2>üõ†Ô∏è Exemplos Pr√°ticos</h2>

      <div class="badge-outline">Exemplo 1: Spawn de Thread com Ownership</div>
      <pre><code>use std::thread;

fn main() {
    let cozinha = String::from("cozinha");
    let handle = thread::spawn(move || {
        // Imagine v√°rios cozinheiros trabalhando juntos, 
        // cada um com sua responsabilidade para evitar confus√£o.
        println!("Trabalhando na {}", cozinha);
    });

    handle.join().unwrap();
}</code></pre>

      <h3>O que acontece aqui?</h3>
      <ul>
        <li><strong>thread::spawn</strong> cria uma nova thread para executar o c√≥digo da closure.</li>
        <li>A palavra <code>move</code> transfere a posse da vari√°vel <code>cozinha</code> para a thread, evitando conflitos.</li>
        <li>Assim como numa cozinha com v√°rios chefs, cada um deve ter seu espa√ßo e responsabilidade para que tudo funcione sem problemas.</li>
        <li><code>join()</code> bloqueia at√© que a thread termine sua execu√ß√£o.</li>
        <li><code>unwrap()</code> trata erros caso a thread falhe.</li>
      </ul>

      <div class="badge-outline">Exemplo 2: Comunica√ß√£o com Channels</div>
      <pre><code>use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        tx.send("Mensagem da thread").unwrap();
    });

    println!("Recebido: {}", rx.recv().unwrap());
}</code></pre>

      <h3>O que acontece aqui?</h3>
      <ul>
        <li><strong>mpsc::channel()</strong> cria um canal para comunica√ß√£o entre threads.</li>
        <li><strong>tx</strong> envia mensagens, <strong>rx</strong> recebe.</li>
        <li>O <strong>move</strong> transfere a posse do transmissor para a thread.</li>
        <li><code>send</code> envia dados, <code>recv</code> aguarda por eles.</li>
      </ul>

      <div class="badge-outline">Exemplo 3: Compartilhamento com Arc e Mutex</div>
      <pre><code>use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Resultado: {}", *counter.lock().unwrap());
}</code></pre>

      <h3>O que acontece aqui?</h3>
      <ul>
        <li><strong>Arc</strong> (Atomic Reference Counted) permite compartilhar dados entre threads sem risco.</li>
        <li><strong>Mutex</strong> garante que apenas uma thread modifique os dados por vez, evitando conflitos.</li>
        <li><code>lock()</code> bloqueia o acesso at√© liberar o recurso.</li>
        <li><code>Arc::clone</code> cria refer√™ncias seguras para m√∫ltiplas threads.</li>
      </ul>
    </section>

    <section>
      <h2> Vantagens Rust </h2>
      <ul>
        <li>Seguran√ßa garantida em tempo de compila√ß√£o</li>
        <li>Desempenho compar√°vel ao C/C++</li>
        <li>Sem coletor de lixo (GC) = controle fino de mem√≥ria</li>
        <li>Ferramentas modernas e comunidade ativa</li>
        <li>Aplic√°vel em jogos, web, IoT, blockchain e muito mais</li>
      </ul>
    </section>

    <section>
      <h2>ü§ñ Rust em Machine Learning</h2>
      <p>Rust tamb√©m vem conquistando espa√ßo em computa√ß√£o cient√≠fica e intelig√™ncia artificial. A linguagem oferece bibliotecas que tornam vi√°vel o desenvolvimento de solu√ß√µes de alto desempenho, incluindo:</p>
      <ul>
        <li><strong>ndarray</strong>: manipula√ß√£o de arrays multidimensionais.</li>
        <li><strong>statrs</strong>: estat√≠stica e an√°lise num√©rica.</li>
        <li><strong>polars</strong>: DataFrame r√°pido e otimizado, similar ao Pandas.</li>
        <li><strong>datafusion</strong>: engine de processamento de dados com SQL e DataFrames.</li>
        <li><strong>tch-rs</strong>: binding para o PyTorch, permitindo deep learning em Rust.</li>
      </ul>
      <p>Apesar de exigir mais esfor√ßo de aprendizado que Python ou R, Rust pode ser uma excelente escolha para quem busca seguran√ßa de mem√≥ria, paralelismo eficiente e performance bruta no processamento de dados.</p>
    </section>

    <section>
      <h2>‚öôÔ∏è Instala√ß√£o do Rust</h2>
      <p>Para come√ßar a programar em Rust, instale o compilador e o gerenciador de pacotes:</p>
      <h3>Linux/macOS</h3>
      <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env</code></pre>

      <h3>Windows</h3>
      <p>Baixe e execute o <a href="https://win.rustup.rs/" target="_blank" rel="noopener noreferrer">rustup-init.exe</a></p>

      <h3>Verifique a instala√ß√£o</h3>
      <pre><code>rustc --version
cargo --version</code></pre>
    </section>

  </main>
</body>
</html>
