<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Multithreading com Seguran√ßa: Descubra o Poder do Rust</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 900px;
      margin: auto;
      padding: 24px;
      line-height: 1.6;
      color: #374151; /* cinza escuro */
      background-color: #f9fafb; /* fundo claro */
    }
    h1 {
      color: #ea580c; /* laranja */
      font-size: 2.5rem;
      font-weight: bold;
      text-align: center;
      margin-bottom: 0.5rem;
    }
    h2 {
      color: #f97316; /* laranja m√©dio */
      font-size: 1.75rem;
      font-weight: 600;
      margin-top: 2rem;
      margin-bottom: 0.75rem;
    }
    p {
      margin-top: 0.5rem;
      font-size: 1.1rem;
    }
    ul {
      list-style: disc inside;
      margin-left: 0;
      margin-top: 0.5rem;
      margin-bottom: 1rem;
      color: #4b5563; /* cinza */
    }
    li strong {
      color: #111827; /* preto para destaque */
    }
    pre {
      background-color: #1f2937; /* cinza escuro */
      color: white;
      padding: 16px;
      border-radius: 6px;
      overflow-x: auto;
      font-family: 'Source Code Pro', monospace, monospace;
      font-size: 0.9rem;
      margin-top: 0.75rem;
      margin-bottom: 1rem;
    }
    .badge-outline {
      border: 1px solid #f97316;
      color: #f97316;
      padding: 4px 10px;
      font-weight: 600;
      border-radius: 20px;
      display: inline-block;
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
    }
  </style>
</head>
<body>
  <main>
    <section style="text-align:center;">
      <h1>Multithreading com Seguran√ßa: Descubra o Poder do Rust</h1>
      <p>Um guia claro, atrativo e t√©cnico sobre multithread com Rust</p>
    </section>

    <section>
      <h2>Por que Multithreading?</h2>
      <p>
        Imagine uma cozinha com v√°rios cozinheiros trabalhando ao mesmo tempo.
        Isso √© o que a programa√ß√£o multithread faz: divide e conquista.
        Por√©m, isso gera desafios de seguran√ßa e bugs complexos.
        O Rust resolve isso com uma abordagem √∫nica baseada em seguran√ßa por design.
      </p>
    </section>

    <section>
      <h2>üîç Recursos Poderosos do Rust</h2>
      <ul>
        <li><strong>Ownership e Borrowing</strong>: evita data races em tempo de compila√ß√£o.</li>
        <li><strong>Traits Send e Sync</strong>: seguran√ßa garantida entre threads.</li>
        <li><strong>Canal (channel)</strong>: comunica√ß√£o segura entre threads.</li>
        <li><strong>Mutex, Arc e ThreadPool</strong>: controle de concorr√™ncia f√°cil e seguro.</li>
        <li><strong>Sem Garbage collector "Coletor de Lixo"</strong>: alta performance com baixo overhead.</li>
      </ul>
    </section>

    <section>
      <h2>üõ†Ô∏è Exemplos Pr√°ticos</h2>

      <div class="badge-outline">Exemplo 1: Spawn de Thread</div>
      <pre><code>use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        println!("Rodando em outra thread!");
    });

    handle.join().unwrap();
}</code></pre>

      <h2>O que acontece aqui?</h2>
      <ul>
        <li><strong>thread::spawn</strong> cria uma nova thread (linha de execu√ß√£o independente) para rodar o c√≥digo dentro da closure <code>|| { ... }</code>.</li>
        <li>O retorno (<code>handle</code>) √© um <strong>JoinHandle</strong>, que permite aguardar o t√©rmino dessa thread.</li>
        <li><code>join()</code> bloqueia a execu√ß√£o da thread principal at√© que a thread criada termine.</li>
        <li><code>unwrap()</code> √© usado para lidar com erros, por exemplo, se a thread <em>panicar</em> (falhar abruptamente).</li>
      </ul>

      <div class="badge-outline">Exemplo 2: Comunica√ß√£o com Channels</div>
      <pre><code>use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        tx.send("Mensagem da thread").unwrap();
    });

    println!("Recebido: {}", rx.recv().unwrap());
}</code></pre>

      <h2>O que acontece aqui?</h2>
      <ul>
        <li><strong>mpsc::channel()</strong> cria um canal para comunica√ß√£o entre threads.</li>
        <li><strong>tx (transmitter):</strong> envia mensagens.</li>
        <li><strong>rx (receiver):</strong> recebe mensagens.</li>
        <li><strong>move</strong> na closure garante que <code>tx</code> seja movido para a thread, permitindo que ela envie mensagens.</li>
        <li><code>send</code> envia um valor pelo canal.</li>
        <li><code>recv</code> bloqueia at√© receber algo.</li>
      </ul>

      <div class="badge-outline">Exemplo 3: Compartilhamento com Arc e Mutex</div>
      <pre><code>use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Resultado: {}", *counter.lock().unwrap());
}</code></pre>
      <p><strong>Explica√ß√£o:</strong></p>
      <ul>
        <li><strong>Arc</strong> (Atomic Reference Counted) permite compartilhar dados imut√°veis ou mut√°veis entre threads, garantindo que o dado seja liberado apenas quando ningu√©m mais estiver usando.</li>
        <li><strong>Mutex</strong> (Mutual Exclusion) garante que apenas uma thread por vez acesse/modifique o dado.</li>
        <li><code>counter.lock()</code> bloqueia o mutex, garantindo acesso exclusivo.</li>
        <li><code>Arc::clone</code> cria mais refer√™ncias para o mesmo valor de forma segura.</li>
      </ul>
    </section>

    <section>
      <h2> Vantagens Reais</h2>
      <ul>
        <li>Seguran√ßa garantida em tempo de compila√ß√£o</li>
        <li>Desempenho compar√°vel ao C/C++</li>
        <li>Sem coletor de lixo = controle fino de mem√≥ria</li>
        <li>Ferramentas modernas e comunidade ativa</li>
        <li>Aplic√°vel em jogos, web, IoT, blockchain e muito mais</li>
      </ul>
    </section>

  </main>
</body>
</html>
