<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Multithreading com Seguran√ßa: Descubra o Poder do Rust</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 900px;
      margin: auto;
      padding: 20px;
      background-color: #f5f7fa;
      color: #333;
      line-height: 1.6;
    }
    h1, h2 {
      color: #d35400;
    }
    h1 {
      font-size: 2.8rem;
      text-align: center;
      margin-bottom: 0.5rem;
    }
    h2 {
      margin-top: 2rem;
      margin-bottom: 0.8rem;
      font-weight: 700;
    }
    p {
      font-size: 1.1rem;
      margin-top: 0.5rem;
    }
    ul {
      list-style: disc inside;
      margin-left: 0;
      margin-bottom: 1.5rem;
      color: #555;
    }
    pre {
      background-color: #2d2d2d;
      color: #f8f8f2;
      padding: 15px;
      border-radius: 6px;
      overflow-x: auto;
      font-family: Consolas, Monaco, monospace;
      font-size: 0.9rem;
      margin-top: 0.75rem;
      margin-bottom: 1.5rem;
    }
    .badge-outline {
      border: 1px solid #d35400;
      color: #d35400;
      padding: 5px 12px;
      font-weight: 600;
      border-radius: 20px;
      display: inline-block;
      margin-bottom: 0.75rem;
      font-size: 0.9rem;
    }

    /* Estilo para a tabela */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
      margin-bottom: 2rem;
    }
    table caption {
      caption-side: top;
      font-weight: 700;
      color: #d35400;
      font-size: 1.3rem;
      margin-bottom: 0.5rem;
      text-align: left;
    }
    table th, table td {
      border: 1px solid #d1d5db;
      padding: 10px 12px;
      text-align: left;
      color: #374151;
    }
    table th {
      background-color: #dba07e; /* tom de laranja claro para header */
      color: white;
    }
    table tbody tr:nth-child(even) {
      background-color: #f9fafb;
    }

    /* Responsividade */
    @media (max-width: 600px) {
      body {
        padding: 12px;
      }
      h1 {
        font-size: 2rem;
      }
      h2 {
        font-size: 1.3rem;
      }
      p, ul {
        font-size: 1rem;
      }
      table th, table td {
        padding: 8px;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <main>
    <section style="text-align:center;">
      <h1>Multithreading com Seguran√ßa: Descubra o Poder do Rust</h1>
      <p>Um guia claro, atrativo e t√©cnico sobre multithread com Rust</p>
    </section>

    <section>
      <h2>Por que Multithreading?</h2>
      <p>
        Imagine uma cozinha com v√°rios cozinheiros trabalhando ao mesmo tempo.
        Isso √© o que a programa√ß√£o multithread faz: divide e conquista.
        Por√©m, isso gera desafios de seguran√ßa e bugs complexos.
        O Rust resolve isso com uma abordagem √∫nica baseada em seguran√ßa por design.
      </p>
    </section>

    <section>
      <h2>üîç Recursos Poderosos do Rust</h2>
      <ul>
        <li><strong>Ownership e Borrowing</strong>: evita data races em tempo de compila√ß√£o.</li>
        <li><strong>Traits Send e Sync</strong>: seguran√ßa garantida entre threads.</li>
        <li><strong>Canal (channel)</strong>: comunica√ß√£o segura entre threads.</li>
        <li><strong>Mutex, Arc e ThreadPool</strong>: controle de concorr√™ncia f√°cil e seguro.</li>
        <li><strong>Sem Garbage collector "Coletor de Lixo"</strong>: alta performance com baixo overhead.</li>
      </ul>
    </section>

    <!-- Tabela adicionada aqui -->
    <section>
      <table>
        <caption>Mecanismos de Compartilhamento Seguro</caption>
        <thead>
          <tr>
            <th>Mecanismo</th>
            <th>Uso Ideal</th>
            <th>Vantagens</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Arc&lt;T&gt;</td>
            <td>Dados imut√°veis compartilhados</td>
            <td>Contagem at√¥mica de refer√™ncias</td>
          </tr>
          <tr>
            <td>Arc&lt;Mutex&lt;T&gt;&gt;</td>
            <td>Dados mut√°veis compartilhados</td>
            <td>Acesso exclusivo garantido</td>
          </tr>
          <tr>
            <td>Arc&lt;RwLock&lt;T&gt;&gt;</td>
            <td>Muitos leitores, poucos escritores</td>
            <td>Mais eficiente que Mutex para leitura</td>
          </tr>
          <tr>
            <td>mpsc::channel</td>
            <td>Comunica√ß√£o entre threads</td>
            <td>Evita locks com message passing</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section>
      <h2>üõ†Ô∏è Exemplos Pr√°ticos</h2>

      <div class="badge-outline">Exemplo 1: Spawn de Thread</div>
      <pre><code>use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        println!("Rodando em outra thread!");
    });

    handle.join().unwrap();
}</code></pre>

      <h2>O que acontece aqui?</h2>
      <ul>
        <li><strong>thread::spawn</strong> cria uma nova thread (linha de execu√ß√£o independente) para rodar o c√≥digo dentro da closure <code>|| { ... }</code>.</li>
        <li>O retorno (<code>handle</code>) √© um <strong>JoinHandle</strong>, que permite aguardar o t√©rmino dessa thread.</li>
        <li><code>join()</code> bloqueia a execu√ß√£o da thread principal at√© que a thread criada termine.</li>
        <li><code>unwrap()</code> √© usado para lidar com erros, por exemplo, se a thread <em>panicar</em> (falhar abruptamente).</li>
      </ul>

      <div class="badge-outline">Exemplo 2: Comunica√ß√£o com Channels</div>
      <pre><code>use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        tx.send("Mensagem da thread").unwrap();
    });

    println!("Recebido: {}", rx.recv().unwrap());
}</code></pre>

      <h2>O que acontece aqui?</h2>
      <ul>
        <li><strong>mpsc::channel()</strong> cria um canal para comunica√ß√£o entre threads.</li>
        <li><strong>tx (transmitter):</strong> envia mensagens.</li>
        <li><strong>rx (receiver):</strong> recebe mensagens.</li>
        <li><strong>move</strong> na closure garante que <code>tx</code> seja movido para a thread, permitindo que ela envie mensagens.</li>
        <li><code>send</code> envia um valor pelo canal.</li>
        <li><code>recv</code> bloqueia at√© receber algo.</li>
      </ul>

      <div class="badge-outline">Exemplo 3: Compartilhamento com Arc e Mutex</div>
      <pre><code>use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Resultado: {}", *counter.lock().unwrap());
}</code></pre>
      <p><strong>Explica√ß√£o:</strong></p>
      <ul>
        <li><strong>Arc</strong> (Atomic Reference Counted) permite compartilhar dados imut√°veis ou mut√°veis entre threads, garantindo que o dado seja liberado apenas quando ningu√©m mais estiver usando.</li>
        <li><strong>Mutex</strong> (Mutual Exclusion) garante que apenas uma thread por vez acesse/modifique o dado.</li>
        <li><code>counter.lock()</code> bloqueia o mutex, garantindo acesso exclusivo.</li>
        <li><code>Arc::clone</code> cria mais refer√™ncias para o mesmo valor de forma segura.</li>
      </ul>
    </section>

    <section>
      <h2>üéØ Vantagens Reais</h2>
      <ul>
        <li>Seguran√ßa garantida em tempo de compila√ß√£o</li>
        <li>Desempenho compar√°vel ao C/C++</li>
        <li>Sem coletor de lixo = controle fino de mem√≥ria</li>
        <li>Ferramentas modernas e comunidade ativa</li>
        <li>Aplic√°vel em jogos, web, IoT, blockchain e muito mais</li>
      </ul>
    </section>

    <section>
      <h2>üìà Autoavalia√ß√£o e Impacto</h2>
      <p>
        A apresenta√ß√£o equilibra profundidade t√©cnica e linguagem acess√≠vel, com
        exemplos reais e analogias claras. O uso da p√°gina web permite engajamento
        com o conte√∫do, e demonstra√ß√£o visual e pr√°tica dos conceitos.
      </p>
    </section>
  </main>
</body>
</html>
